<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Thermal Detective: Classified Cases</title>
    <style>
        /* --- Same CSS Styles as the previous version --- */
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; background-color: #1a1a1a; color: #e0e0e0; display: flex; flex-direction: column; height: 100vh; }
        h1 { color: #ffff00; text-shadow: 2px 2px #ff0000; margin: 5px 0 8px 0; font-size: 2em; text-align: center; flex-shrink: 0; }
        #ui-layout-container { display: flex; flex-direction: column; flex-grow: 1; width: 100%; overflow: hidden; }
        #top-bar { width: 100%; background-color: rgba(20, 20, 40, 0.9); border-bottom: 3px solid #77aaff; padding: 5px 15px; box-sizing: border-box; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; min-height: 50px; }
        #location-info { font-weight: bold; color: #ffff00; font-size: 1.1em; margin-right: 20px; }
        #controls { display: flex; flex-wrap: wrap; gap: 8px; }
        #middle-section { display: flex; flex-direction: row; flex-grow: 1; overflow: hidden; }
        #left-sidebar, #right-sidebar { width: 230px; height: 100%; background-color: rgba(10, 10, 30, 0.9); padding: 10px; box-sizing: border-box; display: flex; flex-direction: column; gap: 15px; overflow-y: auto; font-size: 14px; flex-shrink: 0; }
        #left-sidebar { border-right: 3px solid #77aaff; }
        #right-sidebar { border-left: 3px solid #77aaff; }
        #game-container { flex-grow: 1; position: relative; height: 100%; overflow: hidden; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; cursor: default; background-color: #000; }
        canvas { display: block; position: absolute; top: 0; left: 0; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
        .ui-panel { padding: 8px; border: 1px solid #4466aa; border-radius: 3px; overflow: hidden; display: flex; flex-direction: column; background-color: rgba(30, 30, 50, 0.8); }
        .ui-panel h3 { margin: 0 0 8px 0; padding-bottom: 5px; border-bottom: 1px dashed #77aaff; font-size: 1.1em; color: #aaddff; }
        #notebook-panel { flex-grow: 1; }
        #notebook { flex-grow: 1; overflow-y: auto; white-space: pre-wrap; font-size: 13px; margin-bottom: 10px; border: 1px dashed #335599; padding: 5px; min-height: 100px; background-color: rgba(0,0,10,0.3); }
        #case-panel { flex-shrink: 0; max-height: 40%; }
        #case-info { overflow-y: auto; white-space: pre-wrap; font-size: 13px; background-color: rgba(0,0,10,0.3); padding: 5px; border: 1px dashed #335599; flex-grow: 1; }
        #controls button, #notebook-panel button, #mute-button { padding: 5px 9px; margin: 2px; font-size: 13px; cursor: pointer; background-color: #3366cc; color: white; border: 2px solid #77aaff; border-radius: 0; font-family: 'Courier New', Courier, monospace; text-shadow: 1px 1px #113377; transition: background-color 0.1s ease, transform 0.1s ease; }
        #notebook-panel button { display: block; width: calc(100% - 4px); }
        #controls button:hover, #notebook-panel button:hover, #mute-button:hover { background-color: #5588ee; transform: scale(1.05); }
        #controls button:active, #notebook-panel button:active, #mute-button:active { background-color: #2255bb; transform: scale(1); }
        #dialogue-box { background-color: rgba(30, 10, 50, 0.9); padding: 12px; border: 3px solid #ff55ff; box-shadow: 0 0 8px rgba(255, 85, 255, 0.6); position: absolute; bottom: 10px; left: 10px; width: calc(100% - 20px); max-width: 450px; display: none; pointer-events: auto; text-align: left; z-index: 50; box-sizing: border-box; }
        #dialogue-text { margin-bottom: 10px; font-size: 15px; line-height: 1.4; color: #ffffff; }
        #dialogue-box button { float: right; display: inline-block; width: auto; margin-top: 5px; background-color: #aa33cc; border-color: #ff55ff; text-shadow: 1px 1px #661188;}
        #dialogue-box button:hover { background-color: #cc55ee; }
        #loading-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #111; color: white; display: flex; align-items: center; justify-content: center; font-size: 28px; z-index: 100; font-family: 'Courier New', Courier, monospace; text-shadow: 2px 2px #ff0000; }
        .tooltip { position: fixed; background-color: rgba(0,0,0,0.85); color: white; padding: 5px 8px; border: 1px solid #ccc; border-radius: 3px; font-size: 12px; pointer-events: none; display: none; white-space: nowrap; z-index: 99; }
        #mute-button { position: fixed; top: 10px; right: 15px; width: 80px; z-index: 101; }
    </style>
</head>
<body>
    <h1>Thermal Detective</h1>
    <button id="mute-button" onclick="toggleMute()">Mute</button>

    <div id="ui-layout-container">
        <div id="top-bar">
            <div id="location-info">Location: Agency</div>
            <div id="controls">
                <button id="btn-clinical" onclick="useThermometer('clinical')" title="Measure Body Temp">Clinical</button>
                <button id="btn-lab" onclick="useThermometer('lab')" title="Measure Liquids/Environment">Lab</button>
                <button id="btn-infrared" onclick="useThermometer('infrared')" title="Measure Surface Temp">Infrared</button>
                <button onclick="changeLocation()" title="Go to the next location">Change Location</button>
            </div>
        </div>

        <div id="middle-section">
            <div id="left-sidebar">
                <div class="ui-panel" id="notebook-panel">
                     <h3>Detective Notebook</h3>
                    <div id="notebook">Notes:</div>
                    <button onclick="solveCaseAttempt()" title="Try to solve the current case">Attempt to Solve</button>
                </div>
            </div>

            <div id="game-container">
                 <div id="tooltip"></div>
                 <div id="dialogue-box">
                     <p id="dialogue-text"></p>
                     <button onclick="closeDialogue()">OK</button>
                 </div>
            </div>

            <div id="right-sidebar">
                 <div class="ui-panel" id="case-panel">
                     <h3>Current Case</h3>
                    <strong id="case-title-display">Case: <span id="case-title">None</span></strong>
                    <div id="case-info">Case details will appear here.</div>
                 </div>
            </div>
        </div>
    </div>

     <div id="loading-screen">Loading Assets...</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer, raycaster, mouse;
        let gameObjects = []; // Holds sprites *and* their backdrops now
        let currentCase = null;
        let currentLocation = 'agency';
        let notebookContent = "Notebook Online.\n";
        let audioContext, masterGain, bgmSource = null;
        let isMuted = false;
        let availableLocations = ['agency', 'park', 'school', 'hospital_lobby', 'ice_cream_shop'];
        let currentLocationIndex = 0;
        let hoveredObject = null;
        let tooltipElement;
        const clock = new THREE.Clock();
        let particles = [];
        let particleSystemNeedsUpdate = false;
        let particleTexture;
        let nextLoopStartTime = 0;
        let bgmTimer = null;
        let textureLoader;
        let loadingManager;
        let assetsLoaded = false;

        // --- Constants ---
        const PARTICLE_COUNT_CLICK = 8;
        const PARTICLE_COUNT_SUCCESS = 12;
        const PARTICLE_COUNT_ERROR = 10;
        const PARTICLE_LIFESPAN = 0.5;
        const BACKDROP_OPACITY = 0.55; // Opacity for the circle backdrops

        // --- Asset Mapping ---
        const assetUrls = { /* ... Same assetUrls including backgrounds ... */
            'player': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/detective-removebg-preview.png', 'prof_kelvin': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/thermo-removebg-preview.png', 'dr_fahrenheit': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/Dr._Fahrenheit-removebg-preview.png', 'librarian_leo': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/Librarian_Leo_character-removebg-preview.png', 'worried_parent': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/Gable_character-removebg-preview.png', 'scoops_mcgee': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/chef-removebg-preview.png', 'bench': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/Park_bench-removebg-preview.png', 'bookshelf': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/School%20library%20bookshelf.png?raw=true', 'reception_desk': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/reception%20desk.png?raw=true', 'freezer': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/freezer.png?raw=true', 'counter': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/icecreamcounter.png?raw=true', 'agency_bg': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/detectiveoffice.jpg', 'park_bg': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/park.png', 'school_bg': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/library.png?raw=true', 'hospital_lobby_bg': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/hospital.png?raw=true', 'ice_cream_shop_bg': 'https://raw.githubusercontent.com/wolverinex24/Thermal-Detective/master/icecreamshop.png?raw=true'
        };
        const textures = {};

        // --- Game Data (Cases remain the same) ---
        const cases = [ /* ... Same cases array ... */
             { id: 1, title: "The Fever Mystery", description: "Mr. Gable (Worried Parent) thinks their child might have a fever. Find them at the Hospital Lobby.", location: 'hospital_lobby', objective: "Measure the child's temperature correctly.", cluesNeeded: ['child_temp_measured'], requiredThermometer: 'clinical', targetObjectName: 'Worried Parent', successMessage: "Correct! The clinical thermometer shows 38.5°C (101.3°F). A mild fever. Advised seeing Dr. Fahrenheit.", failureMessage: "Use the Clinical Thermometer on the Worried Parent.", solved: false, educationalNote: "Normal body temp ~37°C (98.6°F). Fever > 38°C (100.4°F)." },
             { id: 2, title: "The Ice Cream Meltdown", description: "Scoops McGee's ice cream is melting! Check his freezer at the Ice Cream Shop.", location: 'ice_cream_shop', objective: "Measure the temperature inside the main freezer.", cluesNeeded: ['freezer_temp_measured'], requiredThermometer: 'lab', targetObjectName: 'Freezer', successMessage: "The Lab thermometer reads -5°C (23°F)! Too warm! Should be ~ -18°C (0°F). Advised repair.", failureMessage: "Measure the Freezer temperature. A Lab or Infrared thermometer might work.", solved: false, educationalNote: "Freezers need temps well below 0°C (32°F). Heat transfer causes warming without proper cooling." }
        ];
        // --- Updated locationData with BENCH SCALE INCREASED ---
        const locationData = {
             'agency': { backgroundAsset: 'agency_bg', objects: [ { name: 'Your Desk', type: 'scenery', pixelArt: 'reception_desk', x: 0, y: -3.5, z: -0.5, scale: 4, dialogue: "Your base of operations." } ] },
             'park': { backgroundAsset: 'park_bg', objects: [
                  // INCREASED Bench Scale
                 { name: 'Bench', type: 'scenery', pixelArt: 'bench', x: 3, y: -3, z: -0.5, scale: 4.5, dialogue: "A nice park bench." },
                 { name: 'Professor Kelvin', type: 'character', pixelArt: 'prof_kelvin', x: -3, y: -0.5, z: 0, scale: 3, dialogue: "Ah, young detective! Careful observation is key!" } ] },
             'school': { backgroundAsset: 'school_bg', objects: [ { name: 'Bookshelf', type: 'scenery', pixelArt: 'bookshelf', x: -3, y: 0.5, z: -0.5, scale: 5, dialogue: "Full of interesting books." }, { name: 'Librarian Leo', type: 'character', pixelArt: 'librarian_leo', x: 3, y: -0.5, z: 0, scale: 3, dialogue: "Need research? The library has resources on temperature scales!" } ] },
             'hospital_lobby': { backgroundAsset: 'hospital_lobby_bg', objects: [ { name: 'Reception Desk', type: 'scenery', pixelArt: 'reception_desk', x: 0, y: -3.5, z: -0.5, scale: 4, dialogue: "The hospital reception." }, { name: 'Dr. Fahrenheit', type: 'character', pixelArt: 'dr_fahrenheit', x: 3.5, y: -0.5, z: 0, scale: 3, dialogue: "Accurate temperature is vital in medicine. Good work!" }, { name: 'Worried Parent', type: 'target', pixelArt: 'worried_parent', x: -3.5, y: -0.5, z: 0, dialogue: "Detective! Please check my child!", caseId: 1, scale: 3 } ] },
              'ice_cream_shop': { backgroundAsset: 'ice_cream_shop_bg', objects: [ { name: 'Counter', type: 'scenery', pixelArt: 'counter', x: 0, y: -3.5, z: -0.5, scale: 4, dialogue: "Where the ice cream is served." }, { name: 'Freezer', type: 'target', pixelArt: 'freezer', x: -3, y: 0, z: -0.5, scale: 3.5, caseId: 2, dialogue: "Looks chilly... or is it?" }, { name: 'Scoops McGee', type: 'character', pixelArt: 'scoops_mcgee', x: 3, y: -0.5, z: 0, scale: 3, dialogue: "My ice cream! It's ruined! Check that freezer!" } ] }
        };

        // --- Initialization ---
        function init() { /* ... Same init logic including LoadingManager ... */
            tooltipElement = document.getElementById('tooltip'); const gameContainer = document.getElementById('game-container'); const loadingScreen = document.getElementById('loading-screen');
            loadingManager = new THREE.LoadingManager( () => { console.log("All assets loaded!"); assetsLoaded = true; loadingScreen.style.display = 'none'; setupInitialGame(); startBGM(); }, (url, itemsLoaded, itemsTotal) => { const progress = Math.round((itemsLoaded / itemsTotal) * 100); loadingScreen.innerText = `Loading Assets: ${progress}% (${itemsLoaded}/${itemsTotal})`; console.log(`Loading file: ${url}`); }, (url) => { console.error('Error loading file:', url); loadingScreen.innerText = `Error loading: ${url}. Please refresh.`; } );
            textureLoader = new THREE.TextureLoader(loadingManager);
            preloadTextures();
             try { window.AudioContext = window.AudioContext || window.webkitAudioContext; audioContext = new AudioContext(); masterGain = audioContext.createGain(); masterGain.gain.value = 1.0; masterGain.connect(audioContext.destination); const unlockAudio = () => { if (audioContext.state === 'suspended') { audioContext.resume().then(() => { console.log("AudioContext resumed."); startBGM(); }); } else if (audioContext.state === 'running') { startBGM(); } document.body.removeEventListener('click', unlockAudio, true); document.body.removeEventListener('touchend', unlockAudio, true); }; document.body.addEventListener('click', unlockAudio, true); document.body.addEventListener('touchend', unlockAudio, true); } catch (e) { console.warn('Web Audio API failed.'); document.getElementById('mute-button').disabled = true; document.getElementById('mute-button').style.opacity = 0.5;}
            scene = new THREE.Scene(); const aspect = gameContainer.clientWidth / gameContainer.clientHeight || 1; const frustumSize = 16; camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 0.1, 100); camera.position.z = 10; renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true }); renderer.setSize(gameContainer.clientWidth, gameContainer.clientHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.domElement.style.width = '100%'; renderer.domElement.style.height = '100%'; gameContainer.appendChild(renderer.domElement);
            raycaster = new THREE.Raycaster(); mouse = new THREE.Vector2(); particleTexture = createPixelParticleTexture();
            window.addEventListener('resize', onWindowResize, false); renderer.domElement.addEventListener('mousemove', onMouseMove, false); renderer.domElement.addEventListener('click', onMouseClick, false); renderer.domElement.addEventListener('mouseleave', onMouseLeave, false);
            animate();
         }

        // --- Asset Preloading ---
        function preloadTextures() { /* ... Same preloading logic ... */ console.log("Preloading textures..."); for (const key in assetUrls) { textures[key] = textureLoader.load(assetUrls[key]); } }

        // --- Initial Game Setup ---
        function setupInitialGame() { /* ... Same setup logic ... */ updateNotebookDisplay(); updateCaseDisplay(); loadLocation(currentLocation); startCase(cases[0]); }

        // --- Texture Generation ---
        function createPixelParticleTexture() { /* ... Same particle texture logic ... */ const size = 8; const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size; const ctx = canvas.getContext('2d'); ctx.fillStyle = '#FFFFFF'; ctx.fillRect(1, 1, size - 2, size - 2); const texture = new THREE.CanvasTexture(canvas); texture.magFilter = THREE.NearestFilter; texture.minFilter = THREE.NearestFilter; return texture; }

        // --- Particle System ---
        function spawnParticles(config) { /* ... Same logic ... */ if (!particleTexture) return; for (let i = 0; i < config.count; i++) { const material = new THREE.SpriteMaterial({ map: particleTexture, color: config.color || new THREE.Color(0xffffff), transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, }); const sprite = new THREE.Sprite(material); sprite.position.copy(config.position); sprite.position.x += (Math.random() - 0.5) * 0.1; sprite.position.y += (Math.random() - 0.5) * 0.1; const baseScale = config.size || 0.15; sprite.scale.set(baseScale, baseScale, 1); const velocityRange = config.velocityRange || 1.5; const particle = { mesh: sprite, velocity: new THREE.Vector3( (Math.random() - 0.5) * velocityRange, (Math.random() - 0.5) * velocityRange + (velocityRange * 0.5), (Math.random() - 0.5) * velocityRange * 0.1 ), life: PARTICLE_LIFESPAN, initialLife: PARTICLE_LIFESPAN, type: config.type || 'sparkle' }; particles.push(particle); scene.add(sprite); } particleSystemNeedsUpdate = true; }
        function updateParticleSystem(delta) { /* ... Same logic ... */ if (!particleSystemNeedsUpdate && particles.length === 0) return; let needsUpdateNextFrame = false; for (let i = particles.length - 1; i >= 0; i--) { const p = particles[i]; p.life -= delta; if (p.life <= 0) { scene.remove(p.mesh); p.mesh.material.dispose(); particles.splice(i, 1); } else { needsUpdateNextFrame = true; p.mesh.position.addScaledVector(p.velocity, delta); p.velocity.y -= 2.5 * delta; const lifePercent = p.life / p.initialLife; p.mesh.material.opacity = lifePercent; } } particleSystemNeedsUpdate = needsUpdateNextFrame; }

        // --- Game Loop ---
        function animate() { /* ... Same logic ... */ requestAnimationFrame(animate); if (!assetsLoaded && !loadingManager.isLoading) { console.warn("Assets appear loaded but flag not set. Finalizing setup."); assetsLoaded = true; document.getElementById('loading-screen').style.display = 'none'; setupInitialGame(); startBGM(); } if (!assetsLoaded) return; const delta = clock.getDelta(); const bobbingSpeed = 2; const bobbingAmount = 0.05; gameObjects.forEach(obj => { if (obj.userData.type === 'character') { if (obj.userData.originalY === undefined) obj.userData.originalY = obj.position.y; obj.position.y = obj.userData.originalY + Math.sin(clock.elapsedTime * bobbingSpeed + obj.id) * bobbingAmount; } if (obj.userData.isSprite && obj.userData.originalScale) { const targetScale = (obj === hoveredObject) ? 1.1 : 1.0; obj.scale.lerp(obj.userData.originalScale.clone().multiplyScalar(targetScale), 0.15); } }); updateParticleSystem(delta); renderer.render(scene, camera); }


        // --- Scene/Location Management ---
        function clearScene() {
            gameObjects.forEach(obj => {
                // Dispose geometry and material EXCEPT for cached textures on sprites
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    // Check if it's a backdrop circle or particle material before disposing texture
                     if (!obj.userData.isSprite && obj.material.map && !(obj.material.map === particleTexture)) {
                         // Don't dispose cached sprite textures or particle texture
                         // Only dispose maps if they were maybe generated dynamically (not currently used)
                     }
                     obj.material.dispose();
                 }
                scene.remove(obj);
            });
            gameObjects = [];
            hoveredObject = null;
            // Keep particle cleanup separate for clarity if needed, though handled above
             for (let i = particles.length - 1; i >= 0; i--) {
                 // Ensure particles are fully cleaned if somehow left in array
                 if(particles[i]?.mesh) scene.remove(particles[i].mesh);
                 if(particles[i]?.mesh?.material) particles[i].mesh.material.dispose();
             }
             particles = [];
            particleSystemNeedsUpdate = false;
        }

        function loadLocation(locationId) {
            clearScene();
            currentLocation = locationId;
            const data = locationData[locationId];
            if (!data) return;

            // --- Set Background ---
            const bgAssetKey = data.backgroundAsset;
            const bgTexture = textures[bgAssetKey];
            if (bgTexture) { scene.background = bgTexture; }
            else { scene.background = new THREE.Color(0x000000); }

            document.getElementById('location-info').innerText = `Location: ${locationId.replace(/_/g, ' ').toUpperCase()}`;

            // --- Load Objects ---
            if (data.objects) {
                data.objects.forEach(objData => {
                    const assetKey = objData.pixelArt;
                    const texture = textures[assetKey];
                    if (!texture) { console.warn(`Texture not found: ${assetKey}`); return; }

                    // Create the main sprite
                    const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, alphaTest: 0.1 });
                    const geometry = new THREE.PlaneGeometry(1, 1);
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(objData.x || 0, objData.y || 0, objData.z || 0);
                    const desiredScale = objData.scale || 1;
                    const imageAspect = texture.image ? (texture.image.width / texture.image.height) : 1;
                    mesh.scale.set(imageAspect * desiredScale, desiredScale, 1);
                    mesh.userData = { ...objData, isClickable: true, isSprite: true, originalScale: mesh.scale.clone() }; // Mark as sprite
                    scene.add(mesh);
                    gameObjects.push(mesh); // Add sprite to game objects

                    // --- Create Backdrop Circle (Only for Characters and Targets) ---
                    if (objData.type === 'character' || objData.type === 'target') {
                        const backdropRadius = Math.max(mesh.scale.x, mesh.scale.y) * 0.5 * 1.15; // 15% larger than half max dimension
                        const backdropGeo = new THREE.CircleGeometry(backdropRadius, 32);
                        const backdropMat = new THREE.MeshBasicMaterial({
                            color: 0xffffff, // White backdrop
                            transparent: true,
                            opacity: BACKDROP_OPACITY,
                            side: THREE.DoubleSide // Render both sides
                        });
                        const backdropCircle = new THREE.Mesh(backdropGeo, backdropMat);
                        backdropCircle.position.copy(mesh.position); // Same X, Y
                        backdropCircle.position.z = mesh.position.z - 0.01; // Slightly behind the sprite
                        backdropCircle.userData = { isBackdrop: true }; // Mark as backdrop, not clickable
                        scene.add(backdropCircle);
                        gameObjects.push(backdropCircle); // Add backdrop to game objects for cleanup
                    }
                });
            }
        }
        function changeLocation() { /* ... Same logic ... */ closeDialogue(); currentLocationIndex = (currentLocationIndex + 1) % availableLocations.length; loadLocation(availableLocations[currentLocationIndex]); }


        // --- Interaction ---
        function updateMousePosition(event) { /* ... Same logic ... */ const rect = renderer.domElement.getBoundingClientRect(); mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; }
        function onMouseMove(event) {
            updateMousePosition(event);
            raycaster.setFromCamera(mouse, camera);
            // IMPORTANT: Filter intersections to only check clickable sprites
            const clickableObjects = gameObjects.filter(obj => obj.userData.isSprite && obj.userData.isClickable);
            const intersects = raycaster.intersectObjects(clickableObjects);
            let newHoveredObject = null;

            if (intersects.length > 0) { // Check intersection with filtered list
                newHoveredObject = intersects[0].object; // This is guaranteed to be a clickable sprite
                renderer.domElement.style.cursor = 'pointer';
                showTooltip(newHoveredObject.userData.name || 'Interactable', event.clientX, event.clientY);
            } else {
                renderer.domElement.style.cursor = 'default';
                hideTooltip();
            }
            if (newHoveredObject !== hoveredObject) {
                hoveredObject = newHoveredObject; // Update hover (scaling handled in animate)
            }
         }
        function onMouseLeave(event) { /* ... Same logic ... */ hoveredObject = null; renderer.domElement.style.cursor = 'default'; hideTooltip(); }
        function onMouseClick(event) {
            updateMousePosition(event);
            raycaster.setFromCamera(mouse, camera);
             // IMPORTANT: Filter intersections to only check clickable sprites
             const clickableObjects = gameObjects.filter(obj => obj.userData.isSprite && obj.userData.isClickable);
             const intersects = raycaster.intersectObjects(clickableObjects);

             if (intersects.length > 0) {
                 const clickedObject = intersects[0].object; // This is the sprite
                 handleObjectClick(clickedObject); // Pass the actual sprite
                 const clickPosition = intersects[0].point;
                 spawnParticles({ position: clickPosition, count: PARTICLE_COUNT_CLICK, color: new THREE.Color(0xffffaa), velocityRange: 1.0, size: 0.1, type: 'click' });
             }
         }
        // handleObjectClick remains the same, operates on sprite data
        function handleObjectClick(object) { playSound('click'); console.log("Clicked on:", object.userData.name || 'Unnamed Object'); const data = object.userData; if (data.dialogue) { showDialogue(data.dialogue); } if (data.type === 'target' && currentCase && data.caseId === currentCase.id) { object.userData.wasClicked = true; console.log(`Target ${data.name} clicked for Case ${currentCase.id}`); } }


        // --- Tooltip ---
        function showTooltip(text, x, y) { /* ... Same logic ... */ tooltipElement.innerText = text; tooltipElement.style.display = 'block'; tooltipElement.style.left = `${x + 15}px`; tooltipElement.style.top = `${y + 10}px`; if (x + tooltipElement.offsetWidth + 15 > window.innerWidth) { tooltipElement.style.left = `${x - tooltipElement.offsetWidth - 5}px`; } if (y + tooltipElement.offsetHeight + 10 > window.innerHeight) { tooltipElement.style.top = `${y - tooltipElement.offsetHeight - 5}px`; } }
        function hideTooltip() { tooltipElement.style.display = 'none'; }

        // --- Dialogue System ---
        function showDialogue(text) { /* ... Same logic ... */ document.getElementById('dialogue-text').innerText = text; document.getElementById('dialogue-box').style.display = 'block'; playSound('dialogue'); }
        function closeDialogue() { /* ... Same logic ... */ document.getElementById('dialogue-box').style.display = 'none'; }

        // --- Gameplay Mechanics ---
        // (startCase, addNotebookEntry, updateNotebookDisplay, updateCaseDisplay, useThermometer, solveCaseAttempt - no changes needed)
        function startCase(caseData) { if (!caseData) return; currentCase = { ...caseData, cluesFound: [] }; console.log("Starting Case:", currentCase.title); updateCaseDisplay(); addNotebookEntry(`--- New Case ---`); addNotebookEntry(`Case: ${currentCase.title}`); addNotebookEntry(`Objective: ${currentCase.objective}`); playSound('new_case'); showDialogue(`New Case: ${currentCase.title}\n${currentCase.description}`); if (currentLocation !== currentCase.location) { addNotebookEntry(`Go to: ${currentCase.location.replace(/_/g, ' ')}`); } }
        function addNotebookEntry(entry) { notebookContent += `\n> ${entry}`; updateNotebookDisplay(); }
        function updateNotebookDisplay() { document.getElementById('notebook').innerText = notebookContent; const notebookDiv = document.getElementById('notebook'); notebookDiv.scrollTop = notebookDiv.scrollHeight; }
        function updateCaseDisplay() { const titleSpan = document.getElementById('case-title'); const infoDiv = document.getElementById('case-info'); if (currentCase) { titleSpan.innerText = currentCase.title + (currentCase.solved ? " (SOLVED)" : ""); infoDiv.innerText = `Objective: ${currentCase.objective}\nLocation: ${currentCase.location.replace(/_/g, ' ')}\n\n${currentCase.description}`; infoDiv.scrollTop = 0; } else { titleSpan.innerText = "None"; infoDiv.innerText = "No active case. Explore or talk to characters."; } }
        function useThermometer(type) { playSound('use_tool'); if (!currentCase || currentCase.solved) { showDialogue("No active case measurement needed now."); addNotebookEntry(`Tried using ${type} thermo, no active case.`); return; } if (currentLocation !== currentCase.location) { showDialogue(`You need to be at ${currentCase.location.replace(/_/g, ' ')} for this measurement.`); addNotebookEntry(`Measurement failed: Wrong location (${currentLocation}).`); playSound('error'); return; } const targetObject = gameObjects.find(obj => obj.userData.isSprite && obj.userData.type === 'target' && obj.userData.caseId === currentCase.id); if (!targetObject) { console.warn(`No target object found for Case ${currentCase.id} in location ${currentLocation}`); showDialogue("There's nothing specific to measure here for this case."); addNotebookEntry(`Measurement failed: No target for Case ${currentCase.id} here.`); playSound('error'); return; } if (!targetObject.userData.wasClicked) { showDialogue(`First, click on the ${targetObject.userData.name} you want to measure.`); addNotebookEntry(`Measurement failed: Target ${targetObject.userData.name} not selected first.`); return; } targetObject.userData.wasClicked = false; addNotebookEntry(`Used ${type} thermo on ${targetObject.userData.name}.`); const particlePos = targetObject.position.clone(); if (type === currentCase.requiredThermometer) { let measurementResult = "", clueFound = ""; if (currentCase.id === 1) { measurementResult = "Reads: 38.5°C (101.3°F)"; clueFound = 'child_temp_measured'; } else if (currentCase.id === 2) { measurementResult = "Reads: -5°C (23°F)"; clueFound = 'freezer_temp_measured'; } showDialogue(`Using the ${type} thermometer on ${targetObject.userData.name}... ${measurementResult}`); addNotebookEntry(`Result: ${measurementResult}`); if (clueFound && !currentCase.cluesFound.includes(clueFound)) { currentCase.cluesFound.push(clueFound); addNotebookEntry(`CLUE FOUND: ${clueFound.replace(/_/g, ' ')}`); playSound('success'); spawnParticles({ position: particlePos, count: PARTICLE_COUNT_SUCCESS, color: new THREE.Color(0xaaffaa), velocityRange: 1.8, size: 0.18, type: 'success' }); } else { spawnParticles({ position: particlePos, count: PARTICLE_COUNT_CLICK, color: new THREE.Color(0xaaaaff), velocityRange: 1.0, size: 0.1, type: 'tool_ok' }); } } else { showDialogue(`The ${type} thermometer isn't suitable for the ${targetObject.userData.name} here.`); addNotebookEntry(`Wrong tool (${type}) for ${targetObject.userData.name}. Needed ${currentCase.requiredThermometer}.`); playSound('error'); spawnParticles({ position: particlePos, count: PARTICLE_COUNT_ERROR, color: new THREE.Color(0xffaaaa), velocityRange: 1.2, size: 0.15, type: 'error' }); } }
        function solveCaseAttempt() { if (!currentCase || currentCase.solved) { showDialogue("No active case to solve."); playSound('error'); return; } let allCluesFound = currentCase.cluesNeeded.every(clue => currentCase.cluesFound.includes(clue)); if (allCluesFound) { currentCase.solved = true; showDialogue(`CASE SOLVED: ${currentCase.title}!\n${currentCase.successMessage}\n\nLearned: ${currentCase.educationalNote}`); addNotebookEntry(`--- CASE SOLVED ---`); addNotebookEntry(`Solved: ${currentCase.title}.`); addNotebookEntry(`Learned: ${currentCase.educationalNote}`); updateCaseDisplay(); playSound('case_solved'); const centerPos = new THREE.Vector3(0, 0, 0); spawnParticles({ position: centerPos, count: 30, color: new THREE.Color(0xffff00), velocityRange: 3.0, size: 0.25, type: 'case_solved' }); const currentCaseId = currentCase.id; currentCase = null; const nextCase = cases.find(c => c.id > currentCaseId && !c.solved); if (nextCase) { setTimeout(() => { startCase(nextCase); }, 4500); } else { setTimeout(() => { showDialogue("CLASSIFIED! You've solved all available cases in Thermopolis!"); addNotebookEntry("--- ALL CASES SOLVED ---"); }, 4500); } } else { showDialogue(`Negative... ${currentCase.failureMessage || "Incomplete intel. Check objectives and notebook."}`); addNotebookEntry(`Solve attempt failed: Missing intel for ${currentCase.title}.`); playSound('error'); const centerPos = new THREE.Vector3(0, 0, 0); spawnParticles({ position: centerPos, count: 20, color: new THREE.Color(0xff4444), velocityRange: 2.0, size: 0.2, type: 'solve_fail' }); } }


        // --- Audio ---
        function toggleMute() { /* ... Same logic ... */ if (!audioContext || !masterGain) return; isMuted = !isMuted; masterGain.gain.setValueAtTime(isMuted ? 0 : 1.0, audioContext.currentTime); document.getElementById('mute-button').innerText = isMuted ? 'Unmute' : 'Mute'; console.log("Audio Muted:", isMuted); if (!isMuted) { if (audioContext.state === 'running') { startBGM(); } else if (audioContext.state === 'suspended') { audioContext.resume().then(() => { console.log("AudioContext resumed on unmute."); startBGM(); }); } } else { stopBGM(); } }
        function playSound(type) { /* ... Same SFX logic ... */ if (!audioContext || !masterGain || isMuted) return; let oscillatorType = 'triangle'; let frequency = 440; let duration = 0.1; let gainValue = 0.07; const sfxGain = audioContext.createGain(); sfxGain.gain.setValueAtTime(gainValue, audioContext.currentTime); sfxGain.connect(masterGain); const oscillator = audioContext.createOscillator(); oscillator.connect(sfxGain); switch (type) { case 'click': frequency = 1200; duration = 0.03; gainValue = 0.05; oscillatorType = 'square'; break; case 'navigate': playNote(392, 0.0, 0.08, 'square', 0.08); playNote(349, 0.08, 0.12, 'square', 0.08); return; case 'success': playNote(523, 0.0, 0.06, 'triangle', 0.1); playNote(659, 0.07, 0.06, 'triangle', 0.1); playNote(784, 0.14, 0.1, 'triangle', 0.1); return; case 'error': playNote(207, 0.0, 0.15, 'sawtooth', 0.1); playNote(196, 0.05, 0.15, 'sawtooth', 0.1); return; case 'new_case': playNote(440, 0.0, 0.1, 'sine', 0.09); playNote(587.33, 0.12, 0.1, 'sine', 0.09); playNote(554.37, 0.24, 0.15, 'sine', 0.09); return; case 'case_solved': playNote(523, 0.0, 0.1, 'square', 0.12); playNote(698, 0.15, 0.1, 'square', 0.12); playNote(784, 0.3, 0.1, 'square', 0.12); playNote(1046, 0.45, 0.3, 'square', 0.12); playNoise(0.0, 0.15, 0.03); playNoise(0.45, 0.2, 0.05); return; case 'use_tool': frequency = 1568; duration = 0.05; oscillatorType = 'square'; gainValue = 0.06; sfxGain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration * 1.2); break; case 'dialogue': frequency = 554; duration = 0.04; oscillatorType = 'triangle'; gainValue = 0.03; break; } sfxGain.gain.value = gainValue; sfxGain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration); if (oscillator) { oscillator.type = oscillatorType; oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime); oscillator.start(audioContext.currentTime); oscillator.stop(audioContext.currentTime + duration); } }
        function playNote(frequency, startTime, duration, type = 'square', gainValue = 0.1) { if (!audioContext || !masterGain || isMuted) return; const noteGain = audioContext.createGain(); noteGain.gain.setValueAtTime(gainValue, audioContext.currentTime + startTime); noteGain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + startTime + duration); noteGain.connect(masterGain); const oscillator = audioContext.createOscillator(); oscillator.type = type; oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime + startTime); oscillator.connect(noteGain); oscillator.start(audioContext.currentTime + startTime); oscillator.stop(audioContext.currentTime + startTime + duration); }
        function playNoise(startTime, duration, gainValue = 0.1) { if (!audioContext || !masterGain || isMuted) return; try { const bufferSize = Math.max(1, Math.floor(audioContext.sampleRate * duration)); const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate); const output = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; } const noiseSource = audioContext.createBufferSource(); noiseSource.buffer = buffer; const noiseGain = audioContext.createGain(); noiseGain.gain.setValueAtTime(gainValue, audioContext.currentTime + startTime); noiseGain.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + startTime + duration); noiseGain.connect(masterGain); noiseSource.connect(noiseGain); noiseSource.start(audioContext.currentTime + startTime); } catch(e){ console.error("Error playing noise:", e); } }
        // --- BGM ---
        // (Uses the improved startBGM and stopBGM)
        function startBGM() { if (!audioContext || audioContext.state !== 'running' || !masterGain || bgmSource || isMuted) { return; } console.log("Starting/Looping Soothing BGM..."); const tempo = 90; const sixteenthNoteTime = (60 / tempo) / 4; const loopDuration = 32 * sixteenthNoteTime; const now = audioContext.currentTime; const loopStartTime = (nextLoopStartTime > now && nextLoopStartTime < now + loopDuration) ? nextLoopStartTime : now + 0.1; const bgmGain = audioContext.createGain(); bgmGain.gain.value = 0.04; bgmGain.connect(masterGain); const currentLoopOscillators = []; const currentLoopNoise = []; bgmSource = { gainNode: bgmGain, oscillators: currentLoopOscillators, noise: currentLoopNoise, startTime: loopStartTime }; const Cmaj = [261.63, 329.63, 392.00, 523.25]; const Amin = [220.00, 261.63, 329.63, 440.00]; const Fmaj = [174.61, 220.00, 261.63, 349.23]; const Gmaj = [196.00, 246.94, 329.63, 392.00]; const progression = [Cmaj, Amin, Fmaj, Gmaj]; function scheduleArp(arpNotes, startTime, gain, type = 'triangle') { const noteDuration = sixteenthNoteTime * 1.5; arpNotes.forEach((freq, index) => { const noteStartTime = startTime + index * sixteenthNoteTime; const osc = audioContext.createOscillator(); osc.type = type; osc.frequency.setValueAtTime(freq * 0.5, noteStartTime); osc.connect(gain); osc.start(noteStartTime); const stopTime = noteStartTime + noteDuration; if (stopTime > noteStartTime) { osc.stop(stopTime); } else { osc.stop(noteStartTime + 0.01); } currentLoopOscillators.push(osc); }); } for(let i=0; i < progression.length; i++){ scheduleArp(progression[i], loopStartTime + i * (8 * sixteenthNoteTime), bgmGain); } function scheduleHat(startTime, gain) { const noiseDur = sixteenthNoteTime * 0.5; const noiseGainVal = 0.015; try { const bufferSize = Math.max(1, Math.floor(audioContext.sampleRate * noiseDur)); const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate); const output = buffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) { output[i] = Math.random() * 2 - 1; } const source = audioContext.createBufferSource(); source.buffer = buffer; const hpFilter = audioContext.createBiquadFilter(); hpFilter.type = 'highpass'; hpFilter.frequency.value = 8000; const hatGain = audioContext.createGain(); hatGain.gain.setValueAtTime(noiseGainVal, startTime); hatGain.gain.exponentialRampToValueAtTime(0.0001, startTime + noiseDur); source.connect(hpFilter).connect(hatGain).connect(gain); source.start(startTime); currentLoopNoise.push(source); } catch (e) { console.error("Error scheduling hat:", e); } } for (let i = 0; i < 8; i++) { scheduleHat(loopStartTime + (i * 4 + 2) * sixteenthNoteTime, bgmGain); } nextLoopStartTime = loopStartTime + loopDuration; const delayUntilNextLoop = (nextLoopStartTime - audioContext.currentTime) * 1000; if (bgmTimer) clearTimeout(bgmTimer); if (delayUntilNextLoop > 10) { bgmTimer = setTimeout(() => { bgmSource = null; startBGM(); }, delayUntilNextLoop); } else { console.warn(`BGM loop delay too small (${delayUntilNextLoop.toFixed(2)}ms), scheduling immediately.`); bgmSource = null; requestAnimationFrame(startBGM); } }
        function stopBGM() { console.log("Stopping BGM..."); if (bgmTimer) { clearTimeout(bgmTimer); bgmTimer = null; } if (bgmSource) { const sourcesToStop = bgmSource; bgmSource = null; sourcesToStop.oscillators.forEach(osc => { try { osc.stop(audioContext.currentTime); osc.disconnect(); } catch (e) { /* ignore */ } }); sourcesToStop.noise.forEach(n => { try { n.stop(audioContext.currentTime); n.disconnect(); } catch (e) { /* ignore */ } }); try { sourcesToStop.gainNode.disconnect(); } catch(e) { /* ignore */ } } nextLoopStartTime = 0; }


        // --- Utility ---
        function onWindowResize() { /* ... Same resize logic ... */ const gameContainer = document.getElementById('game-container'); const containerWidth = gameContainer.clientWidth; const containerHeight = gameContainer.clientHeight; if (containerWidth === 0 || containerHeight === 0) return; const aspect = containerWidth / containerHeight; const frustumSize = 16; camera.left = frustumSize * aspect / -2; camera.right = frustumSize * aspect / 2; camera.top = frustumSize / 2; camera.bottom = frustumSize / -2; camera.updateProjectionMatrix(); renderer.setSize(containerWidth, containerHeight); renderer.domElement.style.width = `${containerWidth}px`; renderer.domElement.style.height = `${containerHeight}px`; }

        // --- Start the game ---
        window.onload = () => {
            init(); // Starts loading assets
        };

    </script>
</body>
</html>
